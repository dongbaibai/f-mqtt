package com.fmqtt.common.config;

import com.fmqtt.common.util.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.Properties;

public class BrokerConfig {

    public final static String AUTHENTICATION_SERVICE_CLASSNAME = "authentication.className";
    public final static String ALLOW_ANONYMOUS = "broker.allow.anonymous";
    public final static String BROKER_MODE = "broker.mode";
    public final static String PWD_FILE_PATH = "pwdFile.path";
    public final static String SESSION_FILE_PATH = "session.path";
    public final static String RETAIN_FILE_PATH = "retain.path";
    public final static String QUEUE_FILE_PATH = "queue.path";
    public final static String INFLIGHT_FILE_PATH = "inflight.path";
    public final static String TIMESTAMP_FILE_PATH = "tick.path";
    public final static String AUTHORIZATION_SERVICE_CLASSNAME = "authorization.className";
    public final static String ACL_FILE_PATH = "aclFile.path";
    public final static String TOPIC_MAX_LENGTH = "broker.topic.max.length";
    public final static String TOPIC_MAX_LEVELS = "broker.topic.max.levels";
    public final static String CLUSTER_SERVICE_CLASSNAME = "cluster.className";
    public final static String CLUSTER_SERVER_NAME = "cluster.serverName";
    public final static String CLUSTER_AKKA_PORT = "cluster.akka.port";
    public final static String SUBSCRIPTION_SERVICE_CLASSNAME = "subscription.className";
    public final static String SUBSCRIPTION_MODE = "subscription.mode";
    public final static String SUBSCRIPTION_DEBUG_ENABLE = "subscription.debugEnable";
    public final static String SUBSCRIPTION_DEBUG_INTERVAL_MILLS = "subscription.debugIntervalMills";
    public final static String SUBSCRIPTION_MAX_CLIENT_COUNT = "subscription.maxClientCount";
    public final static String SUBSCRIPTION_LOCK_TIMEOUT_MILLS = "subscription.lockTimeoutMills";
    public final static String RETAIN_STORE_SYNC = "retain.store.sync";
    public final static String RETAIN_SERVICE_CLASSNAME = "retain.className";
    public final static String PLUGIN_SERVICE_CLASSNAME = "plugin.className";
    public final static String PLUGIN_ITEM_CLASSNAME = "plugin.item.className";
    public final static String QUEUE_SERVICE_CLASSNAME = "queue.className";
    public final static String SESSION_SERVICE_CLASSNAME = "session.className";
    public final static String LIMITING_SERVICE_CLASSNAME = "limiting.className";
    public final static String SESSION_MAX_SUBSCRIPTION_COUNT = "broker.session.maxSubscriptionCount";
    public final static String SESSION_MAX_COUNT = "broker.session.maxSessionCount";
    public final static String WILL_ALLOW_TOPICS = "broker.session.will.allowTopics";
    public final static String WILL_ALLOW_CLIENT_IDS = "broker.session.will.allowClientIds";
//    public final static String SESSION_MAX_QUEUED_MESSAGES = "broker.session.maxQueuedMessages";
    public final static String SESSION_MAX_INFLIGHT_MESSAGES = "broker.session.maxInflightMessages";
    public final static String SESSION_ADJUSTING_INFLIGHT_INTERVAL_MILLS = "broker.session.adjusting.inflight.intervalMills";
    public final static String NETTY_EPOLL_NATIVE = "netty.epoll.native";
    public final static String ALLOW_ZERO_CLIENT_ID = "broker.allow.zero.clientId";
    public final static String CLIENT_ID_MAX_LENGTH = "broker.client.maxId.length";
    public final static String EVENT_SERVICE_CLASSNAME = "event.className";
    public final static String EVENT_PRODUCER_CONNECT_ENABLE = "event.producer.connect.enable";
    public final static String EVENT_PRODUCER_DISCONNECT_ENABLE = "event.producer.disconnect.enable";
    public final static String EVENT_PRODUCER_SUBSCRIBE_ENABLE = "event.producer.subscribe.enable";
    public final static String EVENT_PRODUCER_UNSUBSCRIBE_ENABLE = "event.producer.unsubscribe.enable";
    public final static String REDIS_ADDRESS = "redis.address";
    public final static String REDIS_LOCK_MAX_WAIT_TIME_MILLS = "redis.lock.maxWaitTimeMills";
    public final static String EXECUTOR_MAX_WAIT_TIME_MILLS = "executor.maxWaitTimeMills";
    public final static String EXPIRED_REQUEST_CHECK_INTERVAL_MILLS = "expired.request.checkIntervalMills";
    public final static String EVENT_KAFKA_PRODUCER_CONNECT_TOPIC = "event.kafka.producer.connect.topic";
    public final static String EVENT_KAFKA_PRODUCER_DISCONNECT_TOPIC = "event.kafka.producer.disconnect.topic";
    public final static String EVENT_KAFKA_PRODUCER_SUBSCRIBE_TOPIC = "event.kafka.producer.subscribe.topic";
    public final static String EVENT_KAFKA_PRODUCER_UNSUBSCRIBE_TOPIC = "event.kafka.producer.unsubscribe.topic";
    public final static String EVENT_KAFKA_PRODUCER_ADD_QUEUE_TOPIC = "event.kafka.producer.add.queue.topic";
    public final static String EVENT_KAFKA_PRODUCER_REMOVE_QUEUE_TOPIC = "event.kafka.producer.remove.queue.topic";
    public final static String EVENT_KAFKA_PRODUCER_CLEAN_QUEUE_TOPIC = "event.kafka.producer.clean.queue.topic";
    public final static String EVENT_KAFKA_PRODUCER_ADD_RETAIN_TOPIC = "event.kafka.producer.add.retain.topic";
    public final static String EVENT_KAFKA_SERVERS = "event.kafka.servers";
    public final static String EVENT_KAFKA_PRODUCER_ACK = "event.kafka.producer.ack";
    public final static String EVENT_KAFKA_KEY_SERIALIZER = "event.kafka.key.serializer";
    public final static String EVENT_KAFKA_KEY_DESERIALIZER = "event.kafka.key.deserializer";
    public final static String EVENT_KAFKA_VALUE_SERIALIZER = "event.kafka.value.serializer";
    public final static String EVENT_KAFKA_VALUE_DESERIALIZER = "event.kafka.value.deserializer";
    public final static String EVENT_KAFKA_CONSUMER_SYNC_SUBSCRIBE_TOPICS = "event.kafka.consumer.sync.subscribe.topics";
    public final static String EVENT_KAFKA_CONSUMER_PERSIST_SUBSCRIBE_TOPICS = "event.kafka.consumer.persist.subscribe.topics";
    public final static String EVENT_KAFKA_CONSUMER_POLL_TIMEOUT_MILLS = "event.kafka.consumer.poll.timeoutMills";
    public final static String MQTT_PORT = "broker.mqtt.port";
    public final static String MQTTS_PORT = "broker.mqtts.port";
    public final static String WS_PORT = "broker.ws.port";
    public final static String WSS_PORT = "broker.wss.port";
    public final static String WEBSOCKET_PATH = "broker.webSocket.path";
    public final static String WEBSOCKET_PROTOCOL_CSVLIST = "broker.webSocket.protocol.csvlist";
    public final static String WEBSOCKET_MAX_FRAMESIZE = "broker.webSocket.maxFrameSize";
    public final static String MQTT_MAX_BYTES_IN_MESSAGE = "broker.mqtt.maxBytesInMessage";
    public final static String MQTT_KEEPALIVE = "broker.mqtt.keepalive";
    public final static String LIMIT_CONNECTION_QPS = "broker.limit.connection.qps";
    public final static String LIMIT_DISCONNECTION_QPS = "broker.limit.disconnection.qps";
    public final static String LIMIT_SUB_QPS = "broker.limit.sub.qps";
    public final static String LIMIT_UNSUB_QPS = "broker.limit.unsub.qps";
    public final static String LIMIT_PUB_QPS = "broker.limit.pub.qps";
    public final static String LIMIT_PUBACK_QPS = "broker.limit.puback.qps";
    public final static String LIMIT_PING_QPS = "broker.limit.ping.qps";
    public final static String RETAIN_MAX_BYTES_PER_MESSAGE = "broker.retain.maxBytesPerMessage";
    public final static String RETAIN_ALLOW_TOPICS = "broker.retain.allowTopics";
    public final static String RETAIN_ALLOW_CLIENT_IDS = "broker.retain.allowClientIds";
    public final static String RETAIN_CACHE_ENABLE = "retain.cache.enable";
    public final static String FLUSH_INTERVAL_MILLS = "broker.flush.intervalMills";
    public final static String METRIC_ENABLE = "broker.metric.enable";
    public final static String METRIC_REPORT_INTERVAL_MILLS = "broker.metric.reportIntervalMills";
    public final static String PLUGIN_POOL_SIZE = "broker.plugin.poolSize";
    public final static String NETTY_SO_BACKLOG = "netty.so.backlog";
    public final static String NETTY_TCP_NODELAY = "netty.tcp.nodelay";
    public final static String NETTY_SO_KEEPALIVE = "netty.so.keepalive";
    public final static String NETTY_SndBufSize = "netty.sndBufSize";
    public final static String NETTY_RCVBUFSIZE = "netty.rcvBufSize";
    public final static String TLS_SERVER_MODE = "tls.server.mode";
    public final static String TLS_ENABLE = "tls.enable";
    public final static String TLS_CONFIG_FILE = "tls.config.file";
    public final static String TLS_TEST_MODE_ENABLE = "tls.test.mode.enable";
    public final static String TLS_SERVER_NEED_CLIENT_AUTH = "tls.server.need.client.auth";
    public final static String TLS_SERVER_KEYPATH = "tls.server.keyPath";
    public final static String TLS_SERVER_KEYPASSWORD = "tls.server.keyPassword";
    public final static String TLS_SERVER_CERTPATH = "tls.server.certPath";
    public final static String TLS_SERVER_AUTHCLIENT = "tls.server.authClient";
    public final static String TLS_SERVER_TRUSTCERTPATH = "tls.server.trustCertPath";
    private final static Logger log = LoggerFactory.getLogger(BrokerConfig.class);
    private final static String CONF_FILE_PATH = "conf/fmqtt.conf";
    private final static String BROKER_EXECUTOR_QUEUE_SIZE = "broker.executor.queue.size";
    private final static String H2_AUTO_COMMIT_DELAY_MILLS = "h2.auto.commit.delayMills";
    public static int h2AutoCommitDelayMills = Integer.parseInt(System.getProperty(H2_AUTO_COMMIT_DELAY_MILLS, "0"));
    public static int executorQueueSize = Integer.parseInt(System.getProperty(BROKER_EXECUTOR_QUEUE_SIZE, "1024"));
    public static boolean retainStoreSync = Boolean.parseBoolean(System.getProperty(RETAIN_STORE_SYNC, "false"));
    public static boolean tlsEnable = Boolean.parseBoolean(System.getProperty(TLS_ENABLE, "false"));
    public static boolean tlsTestModeEnable = Boolean.parseBoolean(System.getProperty(TLS_TEST_MODE_ENABLE, "true"));
    public static String tlsServerNeedClientAuth = System.getProperty(TLS_SERVER_NEED_CLIENT_AUTH, "none");
    public static String tlsServerKeyPath = System.getProperty(TLS_SERVER_KEYPATH, null);
    public static String tlsServerKeyPassword = System.getProperty(TLS_SERVER_KEYPASSWORD, null);
    public static String tlsServerCertPath = System.getProperty(TLS_SERVER_CERTPATH, null);
    public static boolean tlsServerAuthClient = Boolean.parseBoolean(System.getProperty(TLS_SERVER_AUTHCLIENT, "false"));
    public static String tlsServerTrustCertPath = System.getProperty(TLS_SERVER_TRUSTCERTPATH, null);
//    public static BrokerMode brokerMode = BrokerMode.valueOf(System.getProperty(BROKER_MODE, BrokerMode.STANDALONE.name()));
    public static TlsMode tlsMode = TlsMode.parse(System.getProperty(TLS_SERVER_MODE, "disabled"));
    public static String tlsConfigFile = System.getProperty(TLS_CONFIG_FILE, "conf/tls.conf");
    public static String serverName = System.getProperty(CLUSTER_SERVER_NAME);
    public static Integer akkaPort = System.getProperty(CLUSTER_AKKA_PORT) == null ?
            null : Integer.parseInt(System.getProperty(CLUSTER_AKKA_PORT));
    public static String eventClassName = System.getProperty(EVENT_SERVICE_CLASSNAME);
    public static boolean eventProducerConnectEnable = Boolean.parseBoolean(System.getProperty(EVENT_PRODUCER_CONNECT_ENABLE, "true"));
    public static boolean eventProducerDisconnectEnable = Boolean.parseBoolean(System.getProperty(EVENT_PRODUCER_DISCONNECT_ENABLE, "true"));
    public static boolean eventProducerSubscribeEnable = Boolean.parseBoolean(System.getProperty(EVENT_PRODUCER_SUBSCRIBE_ENABLE, "true"));
    public static boolean eventProducerUnsubscribeEnable = Boolean.parseBoolean(System.getProperty(EVENT_PRODUCER_UNSUBSCRIBE_ENABLE, "true"));
    public static String redisAddress = System.getProperty(REDIS_ADDRESS);
    public static long redisLockMaxWaitTimeMills = Long.parseLong(System.getProperty(REDIS_LOCK_MAX_WAIT_TIME_MILLS, "1000"));
    public static long executorMaxWaitTimeMills = Long.parseLong(System.getProperty(EXECUTOR_MAX_WAIT_TIME_MILLS, "1000"));
    public static long expiredRequestCheckIntervalMills = Long.parseLong(System.getProperty(EXPIRED_REQUEST_CHECK_INTERVAL_MILLS, "1000"));
    public static String eventKafkaConnectTopic = System.getProperty(EVENT_KAFKA_PRODUCER_CONNECT_TOPIC);
    public static String eventKafkaDisconnectTopic = System.getProperty(EVENT_KAFKA_PRODUCER_DISCONNECT_TOPIC);
    public static String eventKafkaSubscribeTopic = System.getProperty(EVENT_KAFKA_PRODUCER_SUBSCRIBE_TOPIC);
    public static String eventKafkaUnsubscribeTopic = System.getProperty(EVENT_KAFKA_PRODUCER_UNSUBSCRIBE_TOPIC);
    public static String eventKafkaAddRetainTopic = System.getProperty(EVENT_KAFKA_PRODUCER_ADD_RETAIN_TOPIC);
    public static String eventKafkaAddQueueTopic = System.getProperty(EVENT_KAFKA_PRODUCER_ADD_QUEUE_TOPIC);
    public static String eventKafkaRemoveQueueTopic = System.getProperty(EVENT_KAFKA_PRODUCER_REMOVE_QUEUE_TOPIC);
    public static String eventKafkaCleanQueueTopic = System.getProperty(EVENT_KAFKA_PRODUCER_CLEAN_QUEUE_TOPIC);
    public static String eventKafkaServer = System.getProperty(EVENT_KAFKA_SERVERS);
    public static String eventKafkaProducerAck = System.getProperty(EVENT_KAFKA_PRODUCER_ACK);
    public static String eventKafkaKeySerializer = System.getProperty(EVENT_KAFKA_KEY_SERIALIZER
            , "org.apache.kafka.common.serialization.StringSerializer");
    public static String eventKafkaKeyDeserializer = System.getProperty(EVENT_KAFKA_KEY_DESERIALIZER
            , "org.apache.kafka.common.serialization.StringDeserializer");
    public static String eventKafkaValueSerializer = System.getProperty(EVENT_KAFKA_VALUE_SERIALIZER
            , "org.apache.kafka.common.serialization.StringSerializer");
    public static String eventKafkaValueDeserializer = System.getProperty(EVENT_KAFKA_VALUE_DESERIALIZER
            , "org.apache.kafka.common.serialization.StringDeserializer");
    public static String eventKafkaConsumerSyncSubscribeTopics = System.getProperty(EVENT_KAFKA_CONSUMER_SYNC_SUBSCRIBE_TOPICS);

    public static String eventKafkaConsumerPersistSubscribeTopics = System.getProperty(EVENT_KAFKA_CONSUMER_PERSIST_SUBSCRIBE_TOPICS);
    public static long eventKafkaConsumerPollTimeoutMills = Integer.parseInt(System.getProperty(EVENT_KAFKA_CONSUMER_POLL_TIMEOUT_MILLS, "2000"));
    public static String authenticationClassName = System.getProperty(AUTHENTICATION_SERVICE_CLASSNAME);
    public static boolean allowAnonymous = Boolean.parseBoolean(System.getProperty(ALLOW_ANONYMOUS, "true"));
    public static String pwdFilePath = System.getProperty(PWD_FILE_PATH, "conf/pwd.conf");
    public static String sessionFilePath = System.getProperty(SESSION_FILE_PATH, "store/session");
    public static String retainFilePath = System.getProperty(RETAIN_FILE_PATH, "store/retain");
    public static String queueFilePath = System.getProperty(QUEUE_FILE_PATH, "store/queue");
    public static String inflightFilePath = System.getProperty(INFLIGHT_FILE_PATH, "store/inflight");
    public static String timestampFilePath = System.getProperty(TIMESTAMP_FILE_PATH, "store/tick");
    public static String authorizationClassName = System.getProperty(AUTHORIZATION_SERVICE_CLASSNAME);
    public static String aclFilePath = System.getProperty(ACL_FILE_PATH);
    public static int topicMaxLength = Integer.parseInt(System.getProperty(TOPIC_MAX_LENGTH, "32"));
    public static int topicMaxLevels = Integer.parseInt(System.getProperty(TOPIC_MAX_LEVELS, "3"));
    public static String clusterClassName = System.getProperty(CLUSTER_SERVICE_CLASSNAME);
    public static String subscriptionClassName = System.getProperty(SUBSCRIPTION_SERVICE_CLASSNAME);
    public static SubscriptionMode subscriptionMode = SubscriptionMode.valueOf(System.getProperty(SUBSCRIPTION_MODE, SubscriptionMode.HASH.name()));
    public static boolean subscriptionDebugEnable = Boolean.parseBoolean(System.getProperty(SUBSCRIPTION_DEBUG_ENABLE, "false"));
    public static int subscriptionDebugIntervalMills = Integer.parseInt(System.getProperty(SUBSCRIPTION_DEBUG_INTERVAL_MILLS, "10000"));
    public static int subscriptionMaxClientCount = Integer.parseInt(System.getProperty(SUBSCRIPTION_MAX_CLIENT_COUNT, "100"));
    public static int subscriptionLockTimeoutMills = Integer.parseInt(System.getProperty(SUBSCRIPTION_LOCK_TIMEOUT_MILLS, "3000"));
    public static String retainClassName = System.getProperty(RETAIN_SERVICE_CLASSNAME);
    public static String pluginClassName = System.getProperty(PLUGIN_SERVICE_CLASSNAME);
    public static String pluginItemClassNames = System.getProperty(PLUGIN_ITEM_CLASSNAME);
    public static String queueClassName = System.getProperty(QUEUE_SERVICE_CLASSNAME);
    public static String limitingClassName = System.getProperty(LIMITING_SERVICE_CLASSNAME);
    public static String sessionClassName = System.getProperty(SESSION_SERVICE_CLASSNAME);
    public static int sessionMaxSubscriptionCount = Integer.parseInt(System.getProperty(SESSION_MAX_SUBSCRIPTION_COUNT, "100"));
    public static int maxSessionCount = Integer.parseInt(System.getProperty(SESSION_MAX_COUNT, "1000"));
    public static String willAllowTopic = System.getProperty(WILL_ALLOW_TOPICS);
    public static String willAllowClientIds = System.getProperty(WILL_ALLOW_CLIENT_IDS);
//    public static int maxQueuedMessages = Integer.parseInt(System.getProperty(SESSION_MAX_QUEUED_MESSAGES, "200"));
    public static int maxInflightMessages = Integer.parseInt(System.getProperty(SESSION_MAX_INFLIGHT_MESSAGES, "20"));
    public static int adjustingInflightIntervalMills = Integer.parseInt(System.getProperty(SESSION_ADJUSTING_INFLIGHT_INTERVAL_MILLS, "10000"));
    public static boolean useEpollNativeSelector = Boolean.parseBoolean(System.getProperty(NETTY_EPOLL_NATIVE, "true"));
    public static boolean allowZeroClientId = Boolean.parseBoolean(System.getProperty(ALLOW_ZERO_CLIENT_ID, "false"));
    public static int clientIdMaxLength = Integer.parseInt(System.getProperty(CLIENT_ID_MAX_LENGTH, "64"));
    public static int mqttPort = Integer.parseInt(System.getProperty(MQTT_PORT, "1883"));
    public static int mqttsPort = Integer.parseInt(System.getProperty(MQTTS_PORT, "8883"));
    public static int wsPort = Integer.parseInt(System.getProperty(WS_PORT, "80"));
    public static int wssPort = Integer.parseInt(System.getProperty(WSS_PORT, "443"));
    public static String websocketPath = System.getProperty(WEBSOCKET_PATH, "/mqtt");
    public static String protocolCsvList = System.getProperty(WEBSOCKET_PROTOCOL_CSVLIST, "mqtt, mqttv3.1, mqttv3.1.1");
    public static int maxFrameSize = Integer.parseInt(System.getProperty(WEBSOCKET_MAX_FRAMESIZE, "65536"));
    public static int maxBytesInMessage = Integer.parseInt(System.getProperty(MQTT_MAX_BYTES_IN_MESSAGE, "16384"));
    public static int keepalive = Integer.parseInt(System.getProperty(MQTT_KEEPALIVE, "90"));
    public static double limitConnectionQps = Integer.parseInt(System.getProperty(LIMIT_CONNECTION_QPS, "10"));
    public static double limitDisconnectionQps = Integer.parseInt(System.getProperty(LIMIT_DISCONNECTION_QPS, "10"));
    public static double limitSubQps = Integer.parseInt(System.getProperty(LIMIT_SUB_QPS, "10"));
    public static double limitUnSubQps = Integer.parseInt(System.getProperty(LIMIT_UNSUB_QPS, "10"));
    public static double limitPubQps = Integer.parseInt(System.getProperty(LIMIT_PUB_QPS, "10"));
    public static double limitPubAckQps = Integer.parseInt(System.getProperty(LIMIT_PUBACK_QPS, "10"));
    public static double limitPingQps = Integer.parseInt(System.getProperty(LIMIT_PING_QPS, "10"));
    public static int retainMaxBytesPerMessage = Integer.parseInt(System.getProperty(RETAIN_MAX_BYTES_PER_MESSAGE, "104857600"));
    public static String retainAllowTopics = System.getProperty(RETAIN_ALLOW_TOPICS);
    public static String retainAllowClientIds = System.getProperty(RETAIN_ALLOW_CLIENT_IDS);
    public static int flushIntervalMills = Integer.parseInt(System.getProperty(FLUSH_INTERVAL_MILLS, "10000"));
    public static boolean metricEnable = Boolean.parseBoolean(System.getProperty(METRIC_ENABLE, "false"));
//    public static boolean retainCacheEnable = Boolean.parseBoolean(System.getProperty(RETAIN_CACHE_ENABLE, "true"));
    public static int metricReportIntervalMills = Integer.parseInt(System.getProperty(METRIC_REPORT_INTERVAL_MILLS, "5000"));
    public static int pluginPoolSize = Integer.parseInt(System.getProperty(PLUGIN_POOL_SIZE, "1"));

    public static int nettySoBacklog = Integer.parseInt(System.getProperty(NETTY_SO_BACKLOG, "1024"));
    public static boolean nettyTcpNodelay = Boolean.parseBoolean(System.getProperty(NETTY_TCP_NODELAY, "true"));
    public static boolean nettySoKeepalive = Boolean.parseBoolean(System.getProperty(NETTY_SO_KEEPALIVE, "true"));
    public static int serverSocketSndBufSize = Integer.parseInt(System.getProperty(NETTY_SndBufSize, "65535"));
    public static int serverSocketRcvBufSize = Integer.parseInt(System.getProperty(NETTY_RCVBUFSIZE, "65535"));

    public static void loadConfig() throws IOException {
        Properties properties = FileUtils.getPropertiesFromFile(CONF_FILE_PATH);
        extractConfig(properties);
        logTheFinalUsedBrokerConfig();
        log.info("BrokerConfig load finish");
    }

    private static void extractConfig(Properties properties) {
        executorQueueSize = Integer.parseInt(properties.getProperty(BROKER_EXECUTOR_QUEUE_SIZE, String.valueOf(executorQueueSize)));
        redisAddress = properties.getProperty(REDIS_ADDRESS, redisAddress);
        redisLockMaxWaitTimeMills = Long.parseLong(properties.getProperty(REDIS_LOCK_MAX_WAIT_TIME_MILLS, String.valueOf(redisLockMaxWaitTimeMills)));
        authenticationClassName = properties.getProperty(AUTHENTICATION_SERVICE_CLASSNAME, authenticationClassName);
        allowAnonymous = Boolean.parseBoolean(properties.getProperty(ALLOW_ANONYMOUS, String.valueOf(allowAnonymous)));
        pwdFilePath = properties.getProperty(PWD_FILE_PATH, pwdFilePath);
        sessionFilePath = properties.getProperty(SESSION_FILE_PATH, sessionFilePath);
        timestampFilePath = properties.getProperty(TIMESTAMP_FILE_PATH, timestampFilePath);
        authorizationClassName = properties.getProperty(AUTHORIZATION_SERVICE_CLASSNAME);
        aclFilePath = properties.getProperty(ACL_FILE_PATH);
        topicMaxLength = Integer.parseInt(properties.getProperty(TOPIC_MAX_LENGTH, String.valueOf(topicMaxLength)));
        topicMaxLevels = Integer.parseInt(properties.getProperty(TOPIC_MAX_LEVELS, String.valueOf(topicMaxLevels)));
        clusterClassName = properties.getProperty(CLUSTER_SERVICE_CLASSNAME, clusterClassName);
        akkaPort = properties.getProperty(CLUSTER_AKKA_PORT,
                akkaPort == null ? null : String.valueOf(akkaPort)) == null ? null :
                Integer.parseInt(properties.getProperty(CLUSTER_AKKA_PORT,
                        akkaPort == null ? null : String.valueOf(akkaPort)));
        serverName = properties.getProperty(CLUSTER_SERVER_NAME, serverName);
        pluginItemClassNames = properties.getProperty(PLUGIN_ITEM_CLASSNAME, pluginItemClassNames);
        subscriptionClassName = properties.getProperty(SUBSCRIPTION_SERVICE_CLASSNAME, subscriptionClassName);
        subscriptionMode = SubscriptionMode.valueOf(properties.getProperty(SUBSCRIPTION_MODE, subscriptionMode.name()));
        subscriptionDebugEnable = Boolean.parseBoolean(properties.getProperty(SUBSCRIPTION_DEBUG_ENABLE, String.valueOf(subscriptionDebugEnable)));
        subscriptionDebugIntervalMills = Integer.parseInt(properties.getProperty(SUBSCRIPTION_DEBUG_INTERVAL_MILLS, String.valueOf(subscriptionDebugIntervalMills)));
        subscriptionMaxClientCount = Integer.parseInt(properties.getProperty(SUBSCRIPTION_MAX_CLIENT_COUNT, String.valueOf(subscriptionMaxClientCount)));
        subscriptionLockTimeoutMills = Integer.parseInt(properties.getProperty(SUBSCRIPTION_LOCK_TIMEOUT_MILLS, String.valueOf(subscriptionLockTimeoutMills)));
        sessionClassName = properties.getProperty(SESSION_SERVICE_CLASSNAME, sessionClassName);
        retainClassName = properties.getProperty(RETAIN_SERVICE_CLASSNAME, retainClassName);
        pluginClassName = properties.getProperty(PLUGIN_SERVICE_CLASSNAME, pluginClassName);
        eventClassName = properties.getProperty(EVENT_SERVICE_CLASSNAME, eventClassName);
        eventProducerConnectEnable = Boolean.parseBoolean(properties.getProperty(EVENT_PRODUCER_CONNECT_ENABLE, String.valueOf(eventProducerConnectEnable)));
        eventProducerDisconnectEnable = Boolean.parseBoolean(properties.getProperty(EVENT_PRODUCER_DISCONNECT_ENABLE, String.valueOf(eventProducerDisconnectEnable)));
        eventProducerSubscribeEnable = Boolean.parseBoolean(properties.getProperty(EVENT_PRODUCER_SUBSCRIBE_ENABLE, String.valueOf(eventProducerSubscribeEnable)));
        eventProducerUnsubscribeEnable = Boolean.parseBoolean(properties.getProperty(EVENT_PRODUCER_UNSUBSCRIBE_ENABLE, String.valueOf(eventProducerUnsubscribeEnable)));
        eventKafkaConnectTopic = properties.getProperty(EVENT_KAFKA_PRODUCER_CONNECT_TOPIC, eventKafkaConnectTopic);
        eventKafkaDisconnectTopic = properties.getProperty(EVENT_KAFKA_PRODUCER_DISCONNECT_TOPIC, eventKafkaDisconnectTopic);
        eventKafkaSubscribeTopic = properties.getProperty(EVENT_KAFKA_PRODUCER_SUBSCRIBE_TOPIC, eventKafkaSubscribeTopic);
        eventKafkaUnsubscribeTopic = properties.getProperty(EVENT_KAFKA_PRODUCER_UNSUBSCRIBE_TOPIC, eventKafkaUnsubscribeTopic);
        eventKafkaAddRetainTopic = properties.getProperty(EVENT_KAFKA_PRODUCER_ADD_RETAIN_TOPIC, eventKafkaAddRetainTopic);
        eventKafkaAddQueueTopic = properties.getProperty(EVENT_KAFKA_PRODUCER_ADD_QUEUE_TOPIC, eventKafkaAddQueueTopic);
        eventKafkaRemoveQueueTopic = properties.getProperty(EVENT_KAFKA_PRODUCER_REMOVE_QUEUE_TOPIC, eventKafkaRemoveQueueTopic);
        eventKafkaCleanQueueTopic = properties.getProperty(EVENT_KAFKA_PRODUCER_CLEAN_QUEUE_TOPIC, eventKafkaCleanQueueTopic);
        eventKafkaServer = properties.getProperty(EVENT_KAFKA_SERVERS, eventKafkaServer);
        eventKafkaProducerAck = properties.getProperty(EVENT_KAFKA_PRODUCER_ACK, eventKafkaProducerAck);
        eventKafkaKeySerializer = properties.getProperty(EVENT_KAFKA_KEY_SERIALIZER, eventKafkaKeySerializer);
        eventKafkaKeyDeserializer = properties.getProperty(EVENT_KAFKA_KEY_DESERIALIZER, eventKafkaKeyDeserializer);
        eventKafkaValueSerializer = properties.getProperty(EVENT_KAFKA_VALUE_SERIALIZER, eventKafkaValueSerializer);
        eventKafkaValueDeserializer = properties.getProperty(EVENT_KAFKA_VALUE_DESERIALIZER, eventKafkaValueDeserializer);
        eventKafkaConsumerSyncSubscribeTopics = properties.getProperty(EVENT_KAFKA_CONSUMER_SYNC_SUBSCRIBE_TOPICS, eventKafkaConsumerSyncSubscribeTopics);
        eventKafkaConsumerPersistSubscribeTopics = properties.getProperty(EVENT_KAFKA_CONSUMER_PERSIST_SUBSCRIBE_TOPICS, eventKafkaConsumerPersistSubscribeTopics);
        eventKafkaConsumerPollTimeoutMills = Integer.parseInt(properties.getProperty(EVENT_KAFKA_CONSUMER_POLL_TIMEOUT_MILLS
                , String.valueOf(eventKafkaConsumerPollTimeoutMills)));
        useEpollNativeSelector = Boolean.parseBoolean(properties.getProperty(PLUGIN_SERVICE_CLASSNAME, String.valueOf(useEpollNativeSelector)));
        queueClassName = properties.getProperty(QUEUE_SERVICE_CLASSNAME, queueClassName);
        limitingClassName = properties.getProperty(LIMITING_SERVICE_CLASSNAME, limitingClassName);
        clientIdMaxLength = Integer.parseInt(properties.getProperty(CLIENT_ID_MAX_LENGTH, String.valueOf(clientIdMaxLength)));
        allowZeroClientId = Boolean.parseBoolean(System.getProperty(ALLOW_ZERO_CLIENT_ID, String.valueOf(allowZeroClientId)));
        maxSessionCount = Integer.parseInt(properties.getProperty(SESSION_MAX_COUNT, String.valueOf(maxSessionCount)));
        limitConnectionQps = Double.parseDouble(properties.getProperty(LIMIT_CONNECTION_QPS, String.valueOf(limitConnectionQps)));
        limitDisconnectionQps = Double.parseDouble(properties.getProperty(LIMIT_DISCONNECTION_QPS, String.valueOf(limitDisconnectionQps)));
        limitSubQps = Double.parseDouble(properties.getProperty(LIMIT_SUB_QPS, String.valueOf(limitSubQps)));
        limitUnSubQps = Double.parseDouble(properties.getProperty(LIMIT_UNSUB_QPS, String.valueOf(limitUnSubQps)));
        limitPubQps = Double.parseDouble(properties.getProperty(LIMIT_PUB_QPS, String.valueOf(limitPubQps)));
        limitPubAckQps = Double.parseDouble(properties.getProperty(LIMIT_PUBACK_QPS, String.valueOf(limitPubAckQps)));
        limitPingQps = Double.parseDouble(properties.getProperty(LIMIT_PING_QPS, String.valueOf(limitPingQps)));
        retainMaxBytesPerMessage = Integer.parseInt(properties.getProperty(RETAIN_MAX_BYTES_PER_MESSAGE, String.valueOf(retainMaxBytesPerMessage)));
        retainAllowTopics = properties.getProperty(RETAIN_ALLOW_TOPICS, retainAllowTopics);
        retainAllowClientIds = properties.getProperty(RETAIN_ALLOW_CLIENT_IDS, retainAllowClientIds);
        sessionMaxSubscriptionCount = Integer.parseInt(properties.getProperty(SESSION_MAX_SUBSCRIPTION_COUNT, String.valueOf(sessionMaxSubscriptionCount)));
        willAllowTopic = properties.getProperty(WILL_ALLOW_TOPICS, willAllowTopic);
        willAllowClientIds = properties.getProperty(WILL_ALLOW_CLIENT_IDS, willAllowClientIds);
//        maxQueuedMessages = Integer.parseInt(properties.getProperty(SESSION_MAX_QUEUED_MESSAGES, String.valueOf(maxQueuedMessages)));
        maxInflightMessages = Integer.parseInt(properties.getProperty(SESSION_MAX_INFLIGHT_MESSAGES, String.valueOf(maxInflightMessages)));
        adjustingInflightIntervalMills = Integer.parseInt(properties.getProperty(SESSION_ADJUSTING_INFLIGHT_INTERVAL_MILLS, String.valueOf(adjustingInflightIntervalMills)));
        mqttPort = Integer.parseInt(properties.getProperty(MQTT_PORT, String.valueOf(mqttPort)));
        mqttsPort = Integer.parseInt(properties.getProperty(MQTTS_PORT, String.valueOf(mqttsPort)));
        wsPort = Integer.parseInt(properties.getProperty(WS_PORT, String.valueOf(wsPort)));
        wssPort = Integer.parseInt(properties.getProperty(WSS_PORT, String.valueOf(wssPort)));
        websocketPath = properties.getProperty(WEBSOCKET_PATH, websocketPath);
        protocolCsvList = properties.getProperty(WEBSOCKET_PROTOCOL_CSVLIST, protocolCsvList);
        retainStoreSync = Boolean.parseBoolean(properties.getProperty(RETAIN_STORE_SYNC, String.valueOf(retainStoreSync)));
//        retainCacheEnable = Boolean.parseBoolean(properties.getProperty(RETAIN_CACHE_ENABLE, String.valueOf(retainCacheEnable)));
        maxFrameSize = Integer.parseInt(properties.getProperty(WEBSOCKET_MAX_FRAMESIZE, String.valueOf(maxFrameSize)));
        maxBytesInMessage = Integer.parseInt(properties.getProperty(MQTT_MAX_BYTES_IN_MESSAGE, String.valueOf(maxBytesInMessage)));
        keepalive = Integer.parseInt(properties.getProperty(MQTT_KEEPALIVE, String.valueOf(keepalive)));
        flushIntervalMills = Integer.parseInt(properties.getProperty(FLUSH_INTERVAL_MILLS, String.valueOf(flushIntervalMills)));
        metricEnable = Boolean.parseBoolean(properties.getProperty(METRIC_ENABLE, String.valueOf(metricEnable)));
        metricReportIntervalMills = Integer.parseInt(System.getProperty(METRIC_REPORT_INTERVAL_MILLS, String.valueOf(metricReportIntervalMills)));
        pluginPoolSize = Integer.parseInt(System.getProperty(PLUGIN_POOL_SIZE, String.valueOf(pluginPoolSize)));
        nettySoBacklog = Integer.parseInt(properties.getProperty(NETTY_SO_BACKLOG, String.valueOf(nettySoBacklog)));
        nettyTcpNodelay = Boolean.parseBoolean(properties.getProperty(NETTY_TCP_NODELAY, String.valueOf(nettyTcpNodelay)));
        nettySoKeepalive = Boolean.parseBoolean(properties.getProperty(NETTY_SO_KEEPALIVE, String.valueOf(nettySoKeepalive)));
        serverSocketSndBufSize = Integer.parseInt(properties.getProperty(NETTY_SndBufSize, String.valueOf(serverSocketSndBufSize)));
        serverSocketRcvBufSize = Integer.parseInt(properties.getProperty(NETTY_RCVBUFSIZE, String.valueOf(serverSocketRcvBufSize)));
        useEpollNativeSelector = Boolean.parseBoolean(properties.getProperty(NETTY_EPOLL_NATIVE, String.valueOf(useEpollNativeSelector)));
        tlsTestModeEnable = Boolean.parseBoolean(properties.getProperty(TLS_TEST_MODE_ENABLE, String.valueOf(tlsTestModeEnable)));
        tlsServerNeedClientAuth = properties.getProperty(TLS_SERVER_NEED_CLIENT_AUTH, tlsServerNeedClientAuth);
        tlsServerKeyPath = properties.getProperty(TLS_SERVER_KEYPATH, tlsServerKeyPath);
        tlsServerKeyPassword = properties.getProperty(TLS_SERVER_KEYPASSWORD, tlsServerKeyPassword);
        tlsServerCertPath = properties.getProperty(TLS_SERVER_CERTPATH, tlsServerCertPath);
        tlsServerAuthClient = Boolean.parseBoolean(properties.getProperty(TLS_SERVER_AUTHCLIENT, String.valueOf(tlsServerAuthClient)));
        tlsServerTrustCertPath = properties.getProperty(TLS_SERVER_TRUSTCERTPATH, tlsServerTrustCertPath);
        h2AutoCommitDelayMills = Integer.parseInt(properties.getProperty(H2_AUTO_COMMIT_DELAY_MILLS, String.valueOf(h2AutoCommitDelayMills)));
//        brokerMode = BrokerMode.valueOf(properties.getProperty(BROKER_MODE, String.valueOf(brokerMode)));
    }

    private static void logTheFinalUsedBrokerConfig() {
        log.info("Log the final used broker related configuration");
        log.info("{}={}", REDIS_ADDRESS, redisAddress);
        log.info("{}={}", REDIS_LOCK_MAX_WAIT_TIME_MILLS, redisLockMaxWaitTimeMills);
        log.info("{}={}", AUTHENTICATION_SERVICE_CLASSNAME, authenticationClassName);
        log.info("{}={}", ALLOW_ANONYMOUS, allowAnonymous);
        log.info("{}={}", PWD_FILE_PATH, pwdFilePath);
        log.info("{}={}", AUTHORIZATION_SERVICE_CLASSNAME, authorizationClassName);
        log.info("{}={}", ACL_FILE_PATH, aclFilePath);
        log.info("{}={}", TOPIC_MAX_LENGTH, topicMaxLength);
        log.info("{}={}", TOPIC_MAX_LEVELS, topicMaxLevels);
        log.info("{}={}", CLUSTER_SERVICE_CLASSNAME, clusterClassName);
        log.info("{}={}", CLUSTER_AKKA_PORT, akkaPort);
        log.info("{}={}", CLUSTER_SERVER_NAME, serverName);
        log.info("{}={}", PLUGIN_ITEM_CLASSNAME, pluginItemClassNames);
        log.info("{}={}", SUBSCRIPTION_SERVICE_CLASSNAME, subscriptionClassName);
        log.info("{}={}", SUBSCRIPTION_MODE, subscriptionMode);
        log.info("{}={}", SUBSCRIPTION_DEBUG_ENABLE, subscriptionDebugEnable);
        log.info("{}={}", SUBSCRIPTION_DEBUG_INTERVAL_MILLS, subscriptionDebugIntervalMills);
        log.info("{}={}", SUBSCRIPTION_MAX_CLIENT_COUNT, subscriptionMaxClientCount);
        log.info("{}={}", SUBSCRIPTION_LOCK_TIMEOUT_MILLS, subscriptionLockTimeoutMills);
        log.info("{}={}", SESSION_SERVICE_CLASSNAME, sessionClassName);
        log.info("{}={}", RETAIN_SERVICE_CLASSNAME, retainClassName);
        log.info("{}={}", PLUGIN_SERVICE_CLASSNAME, pluginClassName);
        log.info("{}={}", EVENT_SERVICE_CLASSNAME, eventClassName);
        log.info("{}={}", EVENT_PRODUCER_CONNECT_ENABLE, eventProducerConnectEnable);
        log.info("{}={}", EVENT_PRODUCER_DISCONNECT_ENABLE, eventProducerDisconnectEnable);
        log.info("{}={}", EVENT_PRODUCER_SUBSCRIBE_ENABLE, eventProducerSubscribeEnable);
        log.info("{}={}", EVENT_PRODUCER_UNSUBSCRIBE_ENABLE, eventProducerUnsubscribeEnable);
        log.info("{}={}", EVENT_KAFKA_PRODUCER_CONNECT_TOPIC, eventKafkaConnectTopic);
        log.info("{}={}", EVENT_KAFKA_PRODUCER_DISCONNECT_TOPIC, eventKafkaDisconnectTopic);
        log.info("{}={}", EVENT_KAFKA_PRODUCER_SUBSCRIBE_TOPIC, eventKafkaSubscribeTopic);
        log.info("{}={}", EVENT_KAFKA_PRODUCER_UNSUBSCRIBE_TOPIC, eventKafkaUnsubscribeTopic);
        log.info("{}={}", EVENT_KAFKA_SERVERS, eventKafkaServer);
        log.info("{}={}", EVENT_KAFKA_PRODUCER_ACK, eventKafkaProducerAck);
        log.info("{}={}", EVENT_KAFKA_KEY_SERIALIZER, eventKafkaKeySerializer);
        log.info("{}={}", EVENT_KAFKA_KEY_DESERIALIZER, eventKafkaKeyDeserializer);
        log.info("{}={}", EVENT_KAFKA_VALUE_SERIALIZER, eventKafkaValueSerializer);
        log.info("{}={}", EVENT_KAFKA_VALUE_DESERIALIZER, eventKafkaValueDeserializer);
        log.info("{}={}", EVENT_KAFKA_CONSUMER_SYNC_SUBSCRIBE_TOPICS, eventKafkaConsumerSyncSubscribeTopics);
        log.info("{}={}", EVENT_KAFKA_CONSUMER_POLL_TIMEOUT_MILLS, eventKafkaConsumerPollTimeoutMills);
        log.info("{}={}", NETTY_EPOLL_NATIVE, useEpollNativeSelector);
        log.info("{}={}", QUEUE_SERVICE_CLASSNAME, queueClassName);
        log.info("{}={}", CLIENT_ID_MAX_LENGTH, clientIdMaxLength);
        log.info("{}={}", ALLOW_ZERO_CLIENT_ID, allowZeroClientId);
        log.info("{}={}", SESSION_MAX_COUNT, maxSessionCount);
        log.info("{}={}", LIMIT_CONNECTION_QPS, limitConnectionQps);
        log.info("{}={}", LIMIT_DISCONNECTION_QPS, limitDisconnectionQps);
        log.info("{}={}", LIMIT_SUB_QPS, limitSubQps);
        log.info("{}={}", LIMIT_UNSUB_QPS, limitUnSubQps);
        log.info("{}={}", LIMIT_PUB_QPS, limitPubQps);
        log.info("{}={}", LIMIT_PUBACK_QPS, limitPubAckQps);
        log.info("{}={}", LIMIT_PING_QPS, limitPingQps);
        log.info("{}={}", RETAIN_MAX_BYTES_PER_MESSAGE, retainMaxBytesPerMessage);
        log.info("{}={}", RETAIN_ALLOW_TOPICS, retainAllowTopics);
        log.info("{}={}", RETAIN_ALLOW_CLIENT_IDS, retainAllowClientIds);
        log.info("{}={}", SESSION_MAX_SUBSCRIPTION_COUNT, sessionMaxSubscriptionCount);
        log.info("{}={}", WILL_ALLOW_TOPICS, willAllowTopic);
        log.info("{}={}", WILL_ALLOW_CLIENT_IDS, willAllowClientIds);
//        log.info("{}={}", SESSION_MAX_QUEUED_MESSAGES, maxQueuedMessages);
        log.info("{}={}", SESSION_MAX_INFLIGHT_MESSAGES, maxInflightMessages);
        log.info("{}={}", SESSION_ADJUSTING_INFLIGHT_INTERVAL_MILLS, adjustingInflightIntervalMills);
        log.info("{}={}", MQTT_PORT, mqttPort);
        log.info("{}={}", MQTTS_PORT, mqttsPort);
        log.info("{}={}", WS_PORT, wsPort);
        log.info("{}={}", WSS_PORT, wssPort);
        log.info("{}={}", WEBSOCKET_PATH, websocketPath);
        log.info("{}={}", WEBSOCKET_PROTOCOL_CSVLIST, protocolCsvList);
        log.info("{}={}", WEBSOCKET_MAX_FRAMESIZE, maxFrameSize);
        log.info("{}={}", MQTT_MAX_BYTES_IN_MESSAGE, maxBytesInMessage);
        log.info("{}={}", MQTT_KEEPALIVE, keepalive);
        log.info("{}={}", FLUSH_INTERVAL_MILLS, flushIntervalMills);
        log.info("{}={}", METRIC_ENABLE, metricEnable);
        log.info("{}={}", METRIC_REPORT_INTERVAL_MILLS, metricReportIntervalMills);
        log.info("{}={}", PLUGIN_POOL_SIZE, pluginPoolSize);
        log.info("{}={}", NETTY_SO_BACKLOG, nettySoBacklog);
        log.info("{}={}", NETTY_TCP_NODELAY, nettyTcpNodelay);
        log.info("{}={}", NETTY_SO_KEEPALIVE, nettySoKeepalive);
        log.info("{}={}", NETTY_SndBufSize, serverSocketSndBufSize);
        log.info("{}={}", NETTY_RCVBUFSIZE, serverSocketRcvBufSize);
        log.info("{}={}", NETTY_EPOLL_NATIVE, useEpollNativeSelector);
        log.info("{}={}", TLS_TEST_MODE_ENABLE, tlsTestModeEnable);
        log.info("{}={}", TLS_SERVER_NEED_CLIENT_AUTH, tlsServerNeedClientAuth);
        log.info("{}={}", TLS_SERVER_KEYPATH, tlsServerKeyPath);
        log.info("{}={}", TLS_SERVER_KEYPASSWORD, tlsServerKeyPassword);
        log.info("{}={}", TLS_SERVER_CERTPATH, tlsServerCertPath);
        log.info("{}={}", TLS_SERVER_AUTHCLIENT, tlsServerAuthClient);
        log.info("{}={}", TLS_SERVER_TRUSTCERTPATH, tlsServerTrustCertPath);
    }

}
